Initial state
Game 1 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     let (the_sk: skey_t, the_pk: pkey_t) = (s <-R keypairseed_t; (skgen(s), pkgen(s))) in
     return(the_pk);
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       return((let SetupAuthS_Some(enc_6: kemciph_t, ctx_7: context_t) = (let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = (k_2 <-R kemseed_t; AuthEncap_r(k_2, pk_3, the_sk)) in let KeySchedule_Some(ctx_6: context_t) = (let concat(key_6: key_t, nonce_6: nonce_t) = (r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6); concat(get1(r_3), get2(r_3))) in KeySchedule_Some(Context(key_6, nonce_6, nonce_zero)) else KeySchedule_None) in SetupAuthS_Some(enc_5, ctx_6) else SetupAuthS_None else SetupAuthS_None) in let Context_Seal_Some(ct_8: bitstring) = (let Context(key_7: key_t, nonce_7: nonce_t, seq_3: nonce_t) = ctx_7 in ct_7: bitstring <- (nonce_8: nonce_t <- xor(nonce_7, seq_3); Seal_inner(m, aad_9, key_7, nonce_8)); Context_Seal_Some(ct_7) else Context_Seal_None) in SealAuth_Some(enc_6, ct_8) else SealAuth_None else SealAuth_None))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       get E(=pk_4, =the_pk, =enc_7, =c, =aad_10, =info_7) in
         return(OpenAuth_None)
       else
         return((info_hash: bitstring <- info_7; let SetupAuthR_Some(ctx_9: context_t) = (let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, the_sk, pk_4) in let KeySchedule_Some(ctx_8: context_t) = (let concat(key_8: key_t, nonce_9: nonce_t) = (r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_hash); concat(get1(r_4), get2(r_4))) in KeySchedule_Some(Context(key_8, nonce_9, nonce_zero)) else KeySchedule_None) in SetupAuthR_Some(ctx_8) else SetupAuthR_None else SetupAuthR_None) in OpenAuth_Some((let Context(key_9: key_t, nonce_10: nonce_t, seq_4: nonce_t) = ctx_9 in let injbot(pt_7: bitstring) = (nonce_11: nonce_t <- xor(nonce_10, seq_4); Open_inner(c, aad_10, key_9, nonce_11)) in Context_Open_Some(pt_7) else Context_Open_None else Context_Open_None)) else OpenAuth_None))
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         let SealAuth_Some(enc_star: kemciph_t, c_star: bitstring) = (pt_8: bitstring <- test(b, m0, m1); skS_2: skey_t <- skgen(s'); let SetupAuthS_Some(enc_9: kemciph_t, ctx_11: context_t) = (let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = (k_3 <-R kemseed_t; AuthEncap_r(k_3, the_pk, skS_2)) in let KeySchedule_Some(ctx_10: context_t) = (let concat(key_10: key_t, nonce_12: nonce_t) = (r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8); concat(get1(r_5), get2(r_5))) in KeySchedule_Some(Context(key_10, nonce_12, nonce_zero)) else KeySchedule_None) in SetupAuthS_Some(enc_8, ctx_10) else SetupAuthS_None else SetupAuthS_None) in let Context_Seal_Some(ct_10: bitstring) = (let Context(key_11: key_t, nonce_13: nonce_t, seq_5: nonce_t) = ctx_11 in ct_9: bitstring <- (nonce_14: nonce_t <- xor(nonce_13, seq_5); Seal_inner(pt_8, aad_11, key_11, nonce_14)); Context_Seal_Some(ct_9) else Context_Seal_None) in SealAuth_Some(enc_9, ct_10) else SealAuth_None else SealAuth_None) in
           insert E(pkgen(s'), the_pk, enc_star, c_star, aad_11, info_8);
           return((enc_star, c_star))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying expand get, insert
  - Expand get/insert for table E
yields

Game 2 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
  {8}let (the_sk: skey_t, the_pk: pkey_t) = (s <-R keypairseed_t; (skgen(s), pkgen(s))) in
     return(the_pk);
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       return({29}(let SetupAuthS_Some(enc_6: kemciph_t, ctx_7: context_t) = (let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = (k_2 <-R kemseed_t; AuthEncap_r(k_2, pk_3, the_sk)) in {41}let KeySchedule_Some(ctx_6: context_t) = {42}(let concat(key_6: key_t, nonce_6: nonce_t) = (r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6); concat(get1(r_3), get2(r_3))) in KeySchedule_Some(Context(key_6, nonce_6, nonce_zero)) else KeySchedule_None) in SetupAuthS_Some(enc_5, ctx_6) else SetupAuthS_None else SetupAuthS_None) in {79}let Context_Seal_Some(ct_8: bitstring) = {80}(let Context(key_7: key_t, nonce_7: nonce_t, seq_3: nonce_t) = ctx_7 in ct_7: bitstring <- (nonce_8: nonce_t <- xor(nonce_7, seq_3); Seal_inner(m, aad_9, key_7, nonce_8)); Context_Seal_Some(ct_7) else Context_Seal_None) in SealAuth_Some(enc_6, ct_8) else SealAuth_None else SealAuth_None))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser, u_1 = u_3 <= N suchthat defined(E_1[u_2, u_3], E_2[u_2, u_3], E_3[u_2, u_3], E_4[u_2, u_3], E_5[u_2, u_3], E_6[u_2, u_3]) && (E_1[u_2, u_3] = pk_4) && (E_2[u_2, u_3] = the_pk) && (E_3[u_2, u_3] = enc_7) && (E_4[u_2, u_3] = c) && (E_5[u_2, u_3] = aad_10) && (E_6[u_2, u_3] = info_7) then
         return(OpenAuth_None)
       else
         return((info_hash: bitstring <- info_7; {194}let SetupAuthR_Some(ctx_9: context_t) = (let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, the_sk, pk_4) in {205}let KeySchedule_Some(ctx_8: context_t) = {206}(let concat(key_8: key_t, nonce_9: nonce_t) = (r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_hash); concat(get1(r_4), get2(r_4))) in KeySchedule_Some(Context(key_8, nonce_9, nonce_zero)) else KeySchedule_None) in SetupAuthR_Some(ctx_8) else SetupAuthR_None else SetupAuthR_None) in OpenAuth_Some({241}(let Context(key_9: key_t, nonce_10: nonce_t, seq_4: nonce_t) = ctx_9 in let injbot(pt_7: bitstring) = (nonce_11: nonce_t <- xor(nonce_10, seq_4); Open_inner(c, aad_10, key_9, nonce_11)) in Context_Open_Some(pt_7) else Context_Open_None else Context_Open_None)) else OpenAuth_None))
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
{289}    let SealAuth_Some(enc_star: kemciph_t, c_star: bitstring) = (pt_8: bitstring <- test(b, m0, m1); skS_2: skey_t <- skgen(s'); {304}let SetupAuthS_Some(enc_9: kemciph_t, ctx_11: context_t) = (let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = (k_3 <-R kemseed_t; AuthEncap_r(k_3, the_pk, skS_2)) in {316}let KeySchedule_Some(ctx_10: context_t) = {317}(let concat(key_10: key_t, nonce_12: nonce_t) = (r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8); concat(get1(r_5), get2(r_5))) in KeySchedule_Some(Context(key_10, nonce_12, nonce_zero)) else KeySchedule_None) in SetupAuthS_Some(enc_8, ctx_10) else SetupAuthS_None else SetupAuthS_None) in {354}let Context_Seal_Some(ct_10: bitstring) = {355}(let Context(key_11: key_t, nonce_13: nonce_t, seq_5: nonce_t) = ctx_11 in ct_9: bitstring <- (nonce_14: nonce_t <- xor(nonce_13, seq_5); Seal_inner(pt_8, aad_11, key_11, nonce_14)); Context_Seal_Some(ct_9) else Context_Seal_None) in SealAuth_Some(enc_9, ct_10) else SealAuth_None else SealAuth_None) in
           E_1: pkey_t <- pkgen(s');
           E_2: pkey_t <- the_pk;
           E_3: kemciph_t <- enc_star;
           E_4: bitstring <- c_star;
           E_5: bitstring <- aad_11;
           E_6: bitstring <- info_8;
           return((enc_star, c_star))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying expand
  - Expand if/find/let
    - Simplify pattern (the_sk: skey_t, the_pk: pkey_t) (tuple expanded) at 8
    - Remove let at 289
    - Remove let at 304
    - Remove let at 289
    - Simplify pattern concat(key_10: key_t, nonce_12: nonce_t) (tuple expanded) at 317
    - Remove else branch of let at 317
    - Simplify pattern KeySchedule_Some(ctx_10: context_t) (tuple expanded) at 316
    - Remove else branch of let at 316
    - Simplify pattern SetupAuthS_Some(enc_9: kemciph_t, ctx_11: context_t) (tuple expanded) at 304
    - Remove else branch of let at 304
    - Simplify pattern Context(key_11: key_t, nonce_13: nonce_t, seq_5: nonce_t) (tuple expanded) at 355
    - Remove else branch of let at 355
    - Simplify pattern Context_Seal_Some(ct_10: bitstring) (tuple expanded) at 354
    - Remove else branch of let at 354
    - Simplify pattern SealAuth_Some(enc_star: kemciph_t, c_star: bitstring) (tuple expanded) at 289
    - Remove else branch of let at 289
    - Remove let at 194
    - Simplify pattern concat(key_8: key_t, nonce_9: nonce_t) (tuple expanded) at 206
    - Remove else branch of let at 206
    - Simplify pattern KeySchedule_Some(ctx_8: context_t) (tuple expanded) at 205
    - Remove else branch of let at 205
    - Simplify pattern SetupAuthR_Some(ctx_9: context_t) (tuple expanded) at 194
    - Remove else branch of let at 194
    - Simplify pattern Context(key_9: key_t, nonce_10: nonce_t, seq_4: nonce_t) (tuple expanded) at 241
    - Remove else branch of let at 241
    - Remove let at 29
    - Simplify pattern concat(key_6: key_t, nonce_6: nonce_t) (tuple expanded) at 42
    - Remove else branch of let at 42
    - Simplify pattern KeySchedule_Some(ctx_6: context_t) (tuple expanded) at 41
    - Remove else branch of let at 41
    - Simplify pattern SetupAuthS_Some(enc_6: kemciph_t, ctx_7: context_t) (tuple expanded) at 29
    - Remove else branch of let at 29
    - Simplify pattern Context(key_7: key_t, nonce_7: nonce_t, seq_3: nonce_t) (tuple expanded) at 80
    - Remove else branch of let at 80
    - Simplify pattern Context_Seal_Some(ct_8: bitstring) (tuple expanded) at 79
    - Remove else branch of let at 79
yields

Game 3 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     the_pk: pkey_t <- pkgen(s);
     the_sk: skey_t <- skgen(s);
     return(the_pk);
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_2 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_2, pk_3, the_sk) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ctx_6: context_t <- Context(key_6, nonce_6, nonce_zero);
         ctx_7: context_t <- ctx_6;
         enc_6: kemciph_t <- enc_5;
         seq_3: nonce_t <- nonce_zero;
         nonce_7: nonce_t <- nonce_6;
         key_7: key_t <- key_6;
         nonce_8: nonce_t <- xor(nonce_7, seq_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_7, nonce_8);
         ct_8: bitstring <- ct_7;
         return(SealAuth_Some(enc_6, ct_8))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser, u_1 = u_3 <= N suchthat defined(E_1[u_2, u_3], E_2[u_2, u_3], E_3[u_2, u_3], E_4[u_2, u_3], E_5[u_2, u_3], E_6[u_2, u_3]) && (E_1[u_2, u_3] = pk_4) && (E_2[u_2, u_3] = the_pk) && (E_3[u_2, u_3] = enc_7) && (E_4[u_2, u_3] = c) && (E_5[u_2, u_3] = aad_10) && (E_6[u_2, u_3] = info_7) then
         return(OpenAuth_None)
       else
         info_hash: bitstring <- info_7;
         let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, the_sk, pk_4) in
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_hash);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           ctx_8: context_t <- Context(key_8, nonce_9, nonce_zero);
           ctx_9: context_t <- ctx_8;
           seq_4: nonce_t <- nonce_zero;
           nonce_10: nonce_t <- nonce_9;
           key_9: key_t <- key_8;
           nonce_11: nonce_t <- xor(nonce_10, seq_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_9, nonce_11) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         pt_8: bitstring <- test(b, m0, m1);
         skS_2: skey_t <- skgen(s');
         k_3 <-R kemseed_t;
         let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_r(k_3, the_pk, skS_2) in
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           ctx_10: context_t <- Context(key_10, nonce_12, nonce_zero);
           ctx_11: context_t <- ctx_10;
           enc_9: kemciph_t <- enc_8;
           seq_5: nonce_t <- nonce_zero;
           nonce_13: nonce_t <- nonce_12;
           key_11: key_t <- key_10;
           nonce_14: nonce_t <- xor(nonce_13, seq_5);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_11, nonce_14);
           ct_10: bitstring <- ct_9;
           c_star: bitstring <- ct_10;
           enc_star: kemciph_t <- enc_9;
           E_1: pkey_t <- pkgen(s');
           E_2: pkey_t <- the_pk;
           E_3: kemciph_t <- enc_star;
           E_4: bitstring <- c_star;
           E_5: bitstring <- aad_11;
           E_6: bitstring <- info_8;
           return((enc_star, c_star))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on ctx_11 (definition removed, all usages removed)
  - Remove assignments on enc_9 (definition removed, all usages removed)
  - Remove assignments on nonce_13 (definition removed, all usages removed)
  - Remove assignments on key_11 (definition removed, all usages removed)
  - Remove assignments on ct_10 (definition removed, all usages removed)
  - Remove assignments on c_star (definition removed, all usages removed)
  - Remove assignments on enc_star (definition removed, all usages removed)
  - Remove assignments on E_2 (definition removed, all usages removed)
  - Remove assignments on E_3 (definition removed, all usages removed)
  - Remove assignments on E_4 (definition removed, all usages removed)
  - Remove assignments on E_5 (definition removed, all usages removed)
  - Remove assignments on E_6 (definition removed, all usages removed)
  - Remove assignments on info_hash (definition removed, all usages removed)
  - Remove assignments on ctx_9 (definition removed, all usages removed)
  - Remove assignments on nonce_10 (definition removed, all usages removed)
  - Remove assignments on key_9 (definition removed, all usages removed)
  - Remove assignments on ctx_7 (definition removed, all usages removed)
  - Remove assignments on enc_6 (definition removed, all usages removed)
  - Remove assignments on nonce_7 (definition removed, all usages removed)
  - Remove assignments on key_7 (definition removed, all usages removed)
  - Remove assignments on ct_8 (definition removed, all usages removed)
  - Remove assignments on ctx_10 (definition removed, all usages removed)
  - Remove assignments on ctx_8 (definition removed, all usages removed)
  - Remove assignments on ctx_6 (definition removed, all usages removed)
yields

Game 4 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     the_pk: pkey_t <- pkgen(s);
     the_sk: skey_t <- skgen(s);
     return(the_pk);
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_2 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_2, pk_3, the_sk) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         seq_3: nonce_t <- nonce_zero;
         nonce_8: nonce_t <- {59}xor(nonce_6, seq_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_8);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
{104}  find u = u_2 <= Qcperuser, u_1 = u_3 <= N suchthat defined(the_pk[u_3], enc_8[u_2, u_3], ct_9[u_2, u_3], aad_11[u_2, u_3], info_8[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3]) && {126}((E_1[u_2, u_3] = pk_4) && (the_pk[u_3] = the_pk) && (enc_8[u_2, u_3] = enc_7) && (ct_9[u_2, u_3] = c) && (aad_11[u_2, u_3] = aad_10) && (info_8[u_2, u_3] = info_7)) then
         return(OpenAuth_None)
       else
         let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, the_sk, pk_4) in
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           seq_4: nonce_t <- nonce_zero;
           nonce_11: nonce_t <- {206}xor(nonce_9, seq_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_11) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         pt_8: bitstring <- test(b, m0, m1);
         skS_2: skey_t <- skgen(s');
         k_3 <-R kemseed_t;
         let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_r(k_3, the_pk, skS_2) in
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           seq_5: nonce_t <- nonce_zero;
           nonce_14: nonce_t <- {309}xor(nonce_12, seq_5);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_14);
           E_1: pkey_t <- pkgen(s');
           return((enc_8, ct_9))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying simplify [probability N * N * P_pk_coll]
  - Simplification pass
    - Replaced xor(nonce_12, seq_5) with nonce_12 at 309
    - Replaced xor(nonce_9, seq_4) with nonce_9 at 206
    - Replaced ((E_1[u_2, u_3] = pk_4) && (the_pk[u_3] = the_pk) && (enc_8[u_2, u_3] = enc_7) && (ct_9[u_2, u_3] = c) && (aad_11[u_2, u_3] = aad_10) && (info_8[u_2, u_3] = info_7)) with ((E_1[u_2, u_3] = pk_4) && (u_3 = i) && (enc_8[u_2, u_3] = enc_7) && (ct_9[u_2, u_3] = c) && (aad_11[u_2, u_3] = aad_10) && (info_8[u_2, u_3] = info_7)) at 126
    - In branch 1 of find at 104, substituting u_1 with i
    - Replaced defined condition the_pk[u_3], enc_8[u_2, u_3], ct_9[u_2, u_3], aad_11[u_2, u_3], info_8[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3], E_1[u_2, u_3] with info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2] in find at 104
    - Replaced xor(nonce_6, seq_3) with nonce_6 at 59
yields

Game 5 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     the_pk: pkey_t <- pkgen(s);
     the_sk: skey_t <- skgen(s);
     return(the_pk);
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_2 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_2, pk_3, the_sk) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         seq_3: nonce_t <- nonce_zero;
         nonce_8: nonce_t <- nonce_6;
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_8);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && {111}((E_1[u_2] = pk_4) && (i = i) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7)) then
         u_1 <= N <- i;
         return(OpenAuth_None)
       else
         let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, the_sk, pk_4) in
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           seq_4: nonce_t <- nonce_zero;
           nonce_11: nonce_t <- nonce_9;
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_11) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         pt_8: bitstring <- test(b, m0, m1);
         skS_2: skey_t <- skgen(s');
         k_3 <-R kemseed_t;
         let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_r(k_3, the_pk, skS_2) in
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           seq_5: nonce_t <- nonce_zero;
           nonce_14: nonce_t <- nonce_12;
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_14);
           E_1: pkey_t <- pkgen(s');
           return((enc_8, ct_9))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying simplify
  - Simplification pass
    - Replaced ((E_1[u_2] = pk_4) && (i = i) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7)) with ((E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7)) at 111
yields

Game 6 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     the_pk: pkey_t <- pkgen(s);
     the_sk: skey_t <- skgen(s);
     return(the_pk);
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_2 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_2, pk_3, the_sk) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         seq_3: nonce_t <- nonce_zero;
         nonce_8: nonce_t <- nonce_6;
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_8);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         u_1 <= N <- i;
         return(OpenAuth_None)
       else
         let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, the_sk, pk_4) in
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           seq_4: nonce_t <- nonce_zero;
           nonce_11: nonce_t <- nonce_9;
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_11) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         pt_8: bitstring <- test(b, m0, m1);
         skS_2: skey_t <- skgen(s');
         k_3 <-R kemseed_t;
         let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_r(k_3, the_pk, skS_2) in
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           seq_5: nonce_t <- nonce_zero;
           nonce_14: nonce_t <- nonce_12;
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_14);
           E_1: pkey_t <- pkgen(s');
           return((enc_8, ct_9))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying move all binders
  - Move assignment to pt_8
  - Move assignment to seq_4
yields

Game 7 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     the_pk: pkey_t <- pkgen(s);
     the_sk: skey_t <- skgen(s);
     return(the_pk);
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_2 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_2, pk_3, the_sk) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         seq_3: nonce_t <- nonce_zero;
         nonce_8: nonce_t <- nonce_6;
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_8);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         u_1 <= N <- i;
         return(OpenAuth_None)
       else
         let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, the_sk, pk_4) in
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           nonce_11: nonce_t <- nonce_9;
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_11) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         skS_2: skey_t <- skgen(s');
         k_3 <-R kemseed_t;
         let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_r(k_3, the_pk, skS_2) in
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           seq_5: nonce_t <- nonce_zero;
           nonce_14: nonce_t <- nonce_12;
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_14);
           E_1: pkey_t <- pkgen(s');
           return((enc_8, ct_9))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on seq_5 (definition removed, all usages removed)
  - Remove assignments on nonce_14 (definition removed, all usages removed)
  - Remove assignments on nonce_11 (definition removed, all usages removed)
  - Remove assignments on u_1 (definition removed, all usages removed)
  - Remove assignments on seq_3 (definition removed, all usages removed)
  - Remove assignments on nonce_8 (definition removed, all usages removed)
yields

Game 8 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     the_pk: pkey_t <- pkgen(s);
     the_sk: skey_t <- skgen(s);
     return(the_pk);
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_2 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_2, pk_3, the_sk) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, the_sk, pk_4) in
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         skS_2: skey_t <- skgen(s');
         k_3 <-R kemseed_t;
         let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_r(k_3, the_pk, skS_2) in
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((enc_8, ct_9))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying remove assignments of binder the_sk
  - Remove assignments on the_sk (definition removed, all usages removed)
yields

Game 9 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     the_pk: pkey_t <- pkgen(s);
     return(the_pk);
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_2 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_2, pk_3, skgen(s)) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         skS_2: skey_t <- skgen(s');
         k_3 <-R kemseed_t;
         let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_r(k_3, the_pk, skS_2) in
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((enc_8, ct_9))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying remove assignments of binder the_pk
  - Remove assignments on the_pk (definition removed, all usages removed)
yields

Game 10 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_2 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_2, pk_3, skgen(s)) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         skS_2: skey_t <- skgen(s');
         k_3 <-R kemseed_t;
         let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_r(k_3, pkgen(s), skS_2) in
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((enc_8, ct_9))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying equivalence insider_cca(AuthEncap) with variables: s -> s_1 [probability Adv_Insider_CCA(time(context for game 10) + time, N, #Oaenc, #Ochall, #Oadec)]
  - Equivalence insider_cca(AuthEncap) with variables: k_3 -> ks', k_2 -> ks, s -> s_1
yields

Game 11 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = (pk_R: pkey_t <- pk_3; AuthEncap_r(k_4, pk_R, skgen(s))) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
{144}    let AuthDecap_Some(shared_secret_4: kemkey_t) = (pk_S: pkey_t <- pk_4; cd: kemciph_t <- enc_7; find u_4 = ri <= Qcperuser, u_5 = ri_1 <= N suchthat defined(k'[ri, ri_1], ce[ri, ri_1], k'_1[ri, ri_1], s[ri_1], s'_1[ri, ri_1]) && (ce[ri, ri_1] = cd) && (pkgen(s'_1[ri, ri_1]) = pk_S) && (pkgen(s[ri_1]) = pkgen(s)) then AuthDecap_Some(k'_1[u_4, u_5]) else AuthDecap(cd, skgen(s), pk_S)) in
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         skS_2: skey_t <- skgen(s');
         k_6 <-R kemseed_t;
         k'_1 <-R kemkey_t;
{278}    let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = (s'_1: keypairseed_t <- s'; let AuthEncap_tuple(k_5: kemkey_t, ce: kemciph_t) = AuthEncap_r(k_6, pkgen(s), skgen(s'_1)) in k': kemkey_t <- cst_kemkey_t; AuthEncap_tuple(k'_1, ce) else AuthEncap_None) in
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((enc_8, ct_9))
         else
           return(bottom)
       else
         return(bottom)
     ))


Applying expand [probability N * N * P_pk_coll]
  - Expand if/find/let
    - Simplify pattern AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) (tuple expanded) at 278
    - Remove else branch of let at 278
    - Simplify pattern AuthDecap_Some(shared_secret_4: kemkey_t) (tuple expanded) at 144
    - Remove else branch of let at 144
yields

Game 12 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       pk_R: pkey_t <- pk_3;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_4, pk_R, skgen(s)) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         pk_S: pkey_t <- pk_4;
         cd: kemciph_t <- enc_7;
         find u_4 = ri <= Qcperuser, u_5 = ri_1 <= N suchthat defined(k'[ri, ri_1], ce[ri, ri_1], k'_1[ri, ri_1], s[ri_1], s'_1[ri, ri_1]) && (ce[ri, ri_1] = cd) && (pkgen(s'_1[ri, ri_1]) = pk_S) && (pkgen(s[ri_1]) = pkgen(s)) then
           shared_secret_4: kemkey_t <- k'_1[u_4, u_5];
           r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(cd, skgen(s), pk_S) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         skS_2: skey_t <- skgen(s');
         k_6 <-R kemseed_t;
         k'_1 <-R kemkey_t;
         s'_1: keypairseed_t <- s';
         let AuthEncap_tuple(k_5: kemkey_t, ce: kemciph_t) = AuthEncap_r(k_6, pkgen(s), skgen(s'_1)) in
           k': kemkey_t <- cst_kemkey_t;
           enc_8: kemciph_t <- ce;
           shared_secret_5: kemkey_t <- k'_1;
           r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((enc_8, ct_9))
         else
           let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_None in
             r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
             nonce_12: nonce_t <- get2(r_5);
             key_10: key_t <- get1(r_5);
             pt_8: bitstring <- test(b, m0, m1);
             ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
             E_1: pkey_t <- pkgen(s');
             return((enc_8, ct_9))
           else
             return(bottom)
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on skS_2 (definition removed, all usages removed)
  - Remove assignments on s'_1 (definition removed, all usages removed)
  - Remove assignments on shared_secret_5 (definition removed, all usages removed)
  - Remove assignments on enc_8 (definition kept, array references kept)
  - Remove assignments on pk_S (definition removed, all usages removed)
  - Remove assignments on cd (definition removed, all usages removed)
  - Remove assignments on shared_secret_4 (definition removed, all usages removed)
  - Remove assignments on pk_R (definition removed, all usages removed)
yields

Game 13 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_4, pk_3, skgen(s)) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
{140}    find u_4 = ri <= Qcperuser, u_5 = ri_1 <= N suchthat defined(s'[ri, ri_1], k'_1[ri, ri_1], k'[ri, ri_1], ce[ri, ri_1], k'_1[ri, ri_1], s[ri_1]) && {152}((ce[ri, ri_1] = enc_7) && (pkgen(s'[ri, ri_1]) = pk_4) && (pkgen(s[ri_1]) = pkgen(s))) then
           r_4: keys_t <- KeySchedule_auth(k'_1[u_4, u_5], info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         k'_1 <-R kemkey_t;
         let AuthEncap_tuple(k_5: kemkey_t, ce: kemciph_t) = AuthEncap_r(k_6, pkgen(s), skgen(s')) in
           k': kemkey_t <- cst_kemkey_t;
           enc_8: kemciph_t <- ce;
           r_5: keys_t <- KeySchedule_auth(k'_1, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((ce, ct_9))
         else
           let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_None in
             r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
             nonce_12: nonce_t <- get2(r_5);
             key_10: key_t <- get1(r_5);
             pt_8: bitstring <- test(b, m0, m1);
             ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
             E_1: pkey_t <- pkgen(s');
             return((enc_8, ct_9))
           else
             return(bottom)
       else
         return(bottom)
     ))


Applying simplify [probability N * N * P_pk_coll]
  - Simplification pass
    - Replaced ((ce[ri, ri_1] = enc_7) && (pkgen(s'[ri, ri_1]) = pk_4) && (pkgen(s[ri_1]) = pkgen(s))) with ((ce[ri, ri_1] = enc_7) && (pkgen(s'[ri, ri_1]) = pk_4) && (ri_1 = i)) at 152
    - In branch 1 of find at 140, substituting u_5 with i
    - Replaced defined condition s'[ri, ri_1], k'_1[ri, ri_1], k'[ri, ri_1], ce[ri, ri_1], k'_1[ri, ri_1], s[ri_1] with k'[ri], k'_1[ri], s'[ri], ce[ri] in find at 140
yields

Game 14 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_4, pk_3, skgen(s)) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'[ri], k'_1[ri], s'[ri], ce[ri]) && {149}((ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) && (i = i)) then
           u_5 <= N <- i;
           r_4: keys_t <- KeySchedule_auth(k'_1[u_4], info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         k'_1 <-R kemkey_t;
         let AuthEncap_tuple(k_5: kemkey_t, ce: kemciph_t) = AuthEncap_r(k_6, pkgen(s), skgen(s')) in
           k': kemkey_t <- cst_kemkey_t;
           enc_8: kemciph_t <- ce;
           r_5: keys_t <- KeySchedule_auth(k'_1, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((ce, ct_9))
         else
           let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_None in
             r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
             nonce_12: nonce_t <- get2(r_5);
             key_10: key_t <- get1(r_5);
             pt_8: bitstring <- test(b, m0, m1);
             ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
             E_1: pkey_t <- pkgen(s');
             return((enc_8, ct_9))
           else
             return(bottom)
       else
         return(bottom)
     ))


Applying simplify
  - Simplification pass
    - Replaced ((ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) && (i = i)) with ((ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4)) at 149
yields

Game 15 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_4, pk_3, skgen(s)) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'[ri], k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           u_5 <= N <- i;
           r_4: keys_t <- KeySchedule_auth(k'_1[u_4], info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         k'_1 <-R kemkey_t;
         let AuthEncap_tuple(k_5: kemkey_t, ce: kemciph_t) = AuthEncap_r(k_6, pkgen(s), skgen(s')) in
           k': kemkey_t <- cst_kemkey_t;
           enc_8: kemciph_t <- ce;
           r_5: keys_t <- KeySchedule_auth(k'_1, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((ce, ct_9))
         else
           let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_None in
             r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
             nonce_12: nonce_t <- get2(r_5);
             key_10: key_t <- get1(r_5);
             pt_8: bitstring <- test(b, m0, m1);
             ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
             E_1: pkey_t <- pkgen(s');
             return((enc_8, ct_9))
           else
             return(bottom)
       else
         return(bottom)
     ))


Applying move all binders
  - Move random number generation k'_1
yields

Game 16 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_4, pk_3, skgen(s)) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'[ri], k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           u_5 <= N <- i;
           r_4: keys_t <- KeySchedule_auth(k'_1[u_4], info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         let AuthEncap_tuple(k_5: kemkey_t, ce: kemciph_t) = AuthEncap_r(k_6, pkgen(s), skgen(s')) in
           k': kemkey_t <- cst_kemkey_t;
           enc_8: kemciph_t <- ce;
           k'_1 <-R kemkey_t;
           r_5: keys_t <- KeySchedule_auth(k'_1, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((ce, ct_9))
         else
           let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_None in
             r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
             nonce_12: nonce_t <- get2(r_5);
             key_10: key_t <- get1(r_5);
             pt_8: bitstring <- test(b, m0, m1);
             ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
             E_1: pkey_t <- pkgen(s');
             k'_1 <-R kemkey_t;
             return((enc_8, ct_9))
           else
             k'_1 <-R kemkey_t;
             return(bottom)
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on u_5 (definition removed, all usages removed)
yields

Game 17 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = AuthEncap_r(k_4, pk_3, skgen(s)) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'[ri], k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           r_4: keys_t <- KeySchedule_auth(k'_1[u_4], info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         let AuthEncap_tuple(k_5: kemkey_t, ce: kemciph_t) = AuthEncap_r(k_6, pkgen(s), skgen(s')) in
           k': kemkey_t <- cst_kemkey_t;
           enc_8: kemciph_t <- ce;
           k'_1 <-R kemkey_t;
           r_5: keys_t <- KeySchedule_auth(k'_1, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((ce, ct_9))
         else
           let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_None in
             r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
             nonce_12: nonce_t <- get2(r_5);
             key_10: key_t <- get1(r_5);
             pt_8: bitstring <- test(b, m0, m1);
             ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
             E_1: pkey_t <- pkgen(s');
             k'_1 <-R kemkey_t;
             return((enc_8, ct_9))
           else
             k'_1 <-R kemkey_t;
             return(bottom)
       else
         return(bottom)
     ))


Applying equivalence eliminate_failing(AuthEncap)
  - Equivalence eliminate_failing(AuthEncap)
yields

Game 18 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
 {21}  let AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) = (k_7: kemseed_t <- k_4; pk_5: pkey_t <- pk_3; sk_2: skey_t <- skgen(s); AuthEncap_tuple(AuthEncap_key_r(k_7, pk_5, sk_2), AuthEncap_enc_r(k_7, pk_5, sk_2))) in
         r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
         nonce_6: nonce_t <- get2(r_3);
         key_6: key_t <- get1(r_3);
         ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
         return(SealAuth_Some(enc_5, ct_7))
       else
         return(SealAuth_None)
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
{163}    find u_4 = ri <= Qcperuser suchthat defined(k'[ri], k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           r_4: keys_t <- KeySchedule_auth(k'_1[u_4], info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
{316}    let AuthEncap_tuple(k_5: kemkey_t, ce: kemciph_t) = (k_8: kemseed_t <- k_6; pk_6: pkey_t <- pkgen(s); sk_3: skey_t <- skgen(s'); AuthEncap_tuple(AuthEncap_key_r(k_8, pk_6, sk_3), AuthEncap_enc_r(k_8, pk_6, sk_3))) in
           k': kemkey_t <- cst_kemkey_t;
           enc_8: kemciph_t <- ce;
           k'_1 <-R kemkey_t;
           r_5: keys_t <- KeySchedule_auth(k'_1, info_8);
           nonce_12: nonce_t <- get2(r_5);
           key_10: key_t <- get1(r_5);
           pt_8: bitstring <- test(b, m0, m1);
           ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
           E_1: pkey_t <- pkgen(s');
           return((ce, ct_9))
         else
           let AuthEncap_tuple(shared_secret_5: kemkey_t, enc_8: kemciph_t) = AuthEncap_None in
             r_5: keys_t <- KeySchedule_auth(shared_secret_5, info_8);
             nonce_12: nonce_t <- get2(r_5);
             key_10: key_t <- get1(r_5);
             pt_8: bitstring <- test(b, m0, m1);
             ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
             E_1: pkey_t <- pkgen(s');
             k'_1 <-R kemkey_t;
             return((enc_8, ct_9))
           else
             k'_1 <-R kemkey_t;
             return(bottom)
       else
         return(bottom)
     ))


Applying expand
  - Expand if/find/let
    - Simplify pattern AuthEncap_tuple(k_5: kemkey_t, ce: kemciph_t) (tuple expanded) at 316
    - Remove else branch of let at 316
    - Replaced defined condition k'[ri], k'_1[ri], s'[ri], ce[ri] with k'_1[ri], s'[ri], ce[ri] in find at 163
    - Simplify pattern AuthEncap_tuple(shared_secret_3: kemkey_t, enc_5: kemciph_t) (tuple expanded) at 21
    - Remove else branch of let at 21
yields

Game 19 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       k_7: kemseed_t <- k_4;
       pk_5: pkey_t <- pk_3;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_7, pk_5, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_7, pk_5, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], enc_8[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (enc_8[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           r_4: keys_t <- KeySchedule_auth(k'_1[u_4], info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         k_8: kemseed_t <- k_6;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_8, pk_6, sk_3);
         k_5: kemkey_t <- AuthEncap_key_r(k_8, pk_6, sk_3);
         k': kemkey_t <- cst_kemkey_t;
         enc_8: kemciph_t <- ce;
         k'_1 <-R kemkey_t;
         r_5: keys_t <- KeySchedule_auth(k'_1, info_8);
         nonce_12: nonce_t <- get2(r_5);
         key_10: key_t <- get1(r_5);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on k_8 (definition removed, all usages removed)
  - Remove assignments on k_5 (definition removed, all usages removed)
  - Remove assignments on k' (definition removed, all usages removed)
  - Remove assignments on enc_8 (definition removed, all usages removed)
  - Remove assignments on k_7 (definition removed, all usages removed)
  - Remove assignments on pk_5 (definition removed, all usages removed)
yields

Game 20 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
{100}  find u = u_2 <= Qcperuser suchthat defined(ce[u_2], ce[u_2], info_8[u_2], aad_11[u_2], ct_9[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           r_4: keys_t <- KeySchedule_auth(k'_1[u_4], info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         k'_1 <-R kemkey_t;
         r_5: keys_t <- KeySchedule_auth(k'_1, info_8);
         nonce_12: nonce_t <- get2(r_5);
         key_10: key_t <- get1(r_5);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying simplify
  - Simplification pass
    - Replaced defined condition ce[u_2], ce[u_2], info_8[u_2], aad_11[u_2], ct_9[u_2], E_1[u_2] with info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2] in find at 100
yields

Game 21 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           r_4: keys_t <- KeySchedule_auth(k'_1[u_4], info_7);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         k'_1 <-R kemkey_t;
         r_5: keys_t <- KeySchedule_auth(k'_1, info_8);
         nonce_12: nonce_t <- get2(r_5);
         key_10: key_t <- get1(r_5);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying equivalence prf(KeySchedule_auth) with k'_1 [probability Adv_PRF_KeySchedule(time(context for game 21) + time, #Ochall, #Ochall + #Oadec)]
  - Equivalence prf(KeySchedule_auth) with variables: k'_1 -> k_1
yields

Game 22 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           r_4: keys_t <- (x: bitstring <- info_7; find [unique] u_8 = ri_8 <= Qdperuser, u_9 = ri_9 <= N suchthat defined(u_4, u_4[ri_8, ri_9], x[ri_8, ri_9], r_6[ri_8, ri_9]) && (u_4[ri_8, ri_9] = u_4) && (ri_9 = i) && (x = x[ri_8, ri_9]) then r_6[u_8, u_9] orfind  suchthat defined(x_1[u_4], r_7[u_4]) && (x = x_1[u_4]) then r_7[u_4] else r_6 <-R keys_t; r_6);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         k'_1: kemkey_t <- cst_kemkey_t;
         r_5: keys_t <- (x_1: bitstring <- info_8; {388}find [unique] u_6 = ri_4 <= Qdperuser, u_7 = ri_5 <= N suchthat defined(u_4[ri_4, ri_5], x[ri_4, ri_5], r_6[ri_4, ri_5]) && {395}((u_4[ri_4, ri_5] = ich) && (ri_5 = i) && (x_1 = x[ri_4, ri_5])) then r_6[u_6, u_7] orfind  suchthat defined(x_1, r_7) && {423}(x_1 = x_1) then r_7 else r_7 <-R keys_t; r_7);
         nonce_12: nonce_t <- get2(r_5);
         key_10: key_t <- get1(r_5);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying simplify (non-expanded game)
  - Simplification pass
    - Replaced (x_1 = x_1) with true at 423
    - Replaced ((u_4[ri_4, ri_5] = ich) && (ri_5 = i) && (x_1 = x[ri_4, ri_5])) with false at 395
    - Remove branch 1 in find at 388
yields

Game 23 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           r_4: keys_t <- (x: bitstring <- info_7; {182}find [unique] u_8 = ri_8 <= Qdperuser, u_9 = ri_9 <= N suchthat defined(u_4, u_4[ri_8, ri_9], x[ri_8, ri_9], r_6[ri_8, ri_9]) && (u_4[ri_8, ri_9] = u_4) && (ri_9 = i) && (x = x[ri_8, ri_9]) then r_6[u_8, u_9] orfind  suchthat defined(x_1[u_4], r_7[u_4]) && (x = x_1[u_4]) then r_7[u_4] else r_6 <-R keys_t; r_6);
           nonce_9: nonce_t <- get2(r_4);
           key_8: key_t <- get1(r_4);
           let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
             return(OpenAuth_Some(Context_Open_Some(pt_7)))
           else
             return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         k'_1: kemkey_t <- cst_kemkey_t;
         r_5: keys_t <- (x_1: bitstring <- info_8; {388}if defined(x_1, r_7) then r_7 else r_7 <-R keys_t; r_7);
         nonce_12: nonce_t <- get2(r_5);
         key_10: key_t <- get1(r_5);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying expand
  - Expand if/find/let
    - Remove branch 1 in find at 388
    - Find at 388 removed (else branch kept if any)
    - Replaced defined condition u_4, u_4[ri_8, ri_9], x[ri_8, ri_9], r_6[ri_8, ri_9] with u_4[ri_8, ri_9], x[ri_8, ri_9], r_6[ri_8, ri_9] in find at 182
yields

Game 24 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(k'_1[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           x: bitstring <- info_7;
           find [unique] u_8 = ri_8 <= Qdperuser, u_9 = ri_9 <= N suchthat defined(u_4[ri_8, ri_9], x[ri_8, ri_9], r_6[ri_8, ri_9]) && (u_4[ri_8, ri_9] = u_4) && (ri_9 = i) && (x = x[ri_8, ri_9]) then
             r_4: keys_t <- r_6[u_8, u_9];
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat defined(x_1[u_4], r_7[u_4]) && (x = x_1[u_4]) then
             r_4: keys_t <- r_7[u_4];
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             r_6 <-R keys_t;
             r_4: keys_t <- r_6;
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         k'_1: kemkey_t <- cst_kemkey_t;
         x_1: bitstring <- info_8;
         r_7 <-R keys_t;
         r_5: keys_t <- r_7;
         nonce_12: nonce_t <- get2(r_5);
         key_10: key_t <- get1(r_5);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on k'_1 (definition removed, all usages removed)
  - Remove assignments on x_1 (definition removed, all usages removed)
  - Remove assignments on r_5 (definition removed, all usages removed)
  - Remove assignments on x (definition point kept, all usages removed)
  - Remove assignments on r_4 (definition removed, all usages removed)
  - Remove assignments on r_4 (definition removed, all usages removed)
  - Remove assignments on r_4 (definition removed, all usages removed)
yields

Game 25 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
{154}    find u_4 = ri <= Qcperuser suchthat defined(ce[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           x: bitstring <- cst_bitstring;
{179}      find [unique] u_8 = ri_8 <= Qdperuser, u_9 = ri_9 <= N suchthat defined(info_7[ri_8, ri_9], x[ri_8, ri_9], u_4[ri_8, ri_9], r_6[ri_8, ri_9]) && (u_4[ri_8, ri_9] = u_4) && (ri_9 = i) && (info_7 = info_7[ri_8, ri_9]) then
             nonce_9: nonce_t <- get2(r_6[u_8, u_9]);
             key_8: key_t <- get1(r_6[u_8, u_9]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat defined(info_8[u_4], ce[u_4], r_7[u_4]) && (info_7 = info_8[u_4]) then
             nonce_9: nonce_t <- get2(r_7[u_4]);
             key_8: key_t <- get1(r_7[u_4]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             r_6 <-R keys_t;
             nonce_9: nonce_t <- get2(r_6);
             key_8: key_t <- get1(r_6);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         r_7 <-R keys_t;
         nonce_12: nonce_t <- get2(r_7);
         key_10: key_t <- get1(r_7);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying simplify
  - Simplification pass
    - Replaced defined condition info_8[u_4], ce[u_4], r_7[u_4] with an empty condition in find at 179
    - In branch 1 of find at 179, substituting u_9 with i
    - Replaced defined condition info_7[ri_8, ri_9], x[ri_8, ri_9], u_4[ri_8, ri_9], r_6[ri_8, ri_9] with r_6[ri_8], info_7[ri_8], u_4[ri_8] in find at 179
    - Replaced defined condition ce[ri], s'[ri], ce[ri] with r_7[ri], info_8[ri], s'[ri], ce[ri] in find at 154
yields

Game 26 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(r_7[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           x: bitstring <- cst_bitstring;
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(r_6[ri_8], info_7[ri_8], u_4[ri_8]) && {188}((u_4[ri_8] = u_4) && (i = i) && (info_7 = info_7[ri_8])) then
             u_9 <= N <- i;
             nonce_9: nonce_t <- get2(r_6[u_8]);
             key_8: key_t <- get1(r_6[u_8]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
             nonce_9: nonce_t <- get2(r_7[u_4]);
             key_8: key_t <- get1(r_7[u_4]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             r_6 <-R keys_t;
             nonce_9: nonce_t <- get2(r_6);
             key_8: key_t <- get1(r_6);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         r_7 <-R keys_t;
         nonce_12: nonce_t <- get2(r_7);
         key_10: key_t <- get1(r_7);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying simplify
  - Simplification pass
    - Replaced ((u_4[ri_8] = u_4) && (i = i) && (info_7 = info_7[ri_8])) with ((u_4[ri_8] = u_4) && (info_7 = info_7[ri_8])) at 188
yields

Game 27 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(r_7[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           x: bitstring <- cst_bitstring;
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(r_6[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             u_9 <= N <- i;
             nonce_9: nonce_t <- get2(r_6[u_8]);
             key_8: key_t <- get1(r_6[u_8]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
             nonce_9: nonce_t <- get2(r_7[u_4]);
             key_8: key_t <- get1(r_7[u_4]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             r_6 <-R keys_t;
             nonce_9: nonce_t <- get2(r_6);
             key_8: key_t <- get1(r_6);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         r_7 <-R keys_t;
         nonce_12: nonce_t <- get2(r_7);
         key_10: key_t <- get1(r_7);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying move all binders
  - Move assignment to x
yields

Game 28 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(r_7[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(r_6[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             u_9 <= N <- i;
             nonce_9: nonce_t <- get2(r_6[u_8]);
             key_8: key_t <- get1(r_6[u_8]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
             nonce_9: nonce_t <- get2(r_7[u_4]);
             key_8: key_t <- get1(r_7[u_4]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             r_6 <-R keys_t;
             nonce_9: nonce_t <- get2(r_6);
             key_8: key_t <- get1(r_6);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         r_7 <-R keys_t;
         nonce_12: nonce_t <- get2(r_7);
         key_10: key_t <- get1(r_7);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on u_9 (definition removed, all usages removed)
yields

Game 29 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(r_7[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(r_6[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             nonce_9: nonce_t <- get2(r_6[u_8]);
             key_8: key_t <- get1(r_6[u_8]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
             nonce_9: nonce_t <- get2(r_7[u_4]);
             key_8: key_t <- get1(r_7[u_4]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             r_6 <-R keys_t;
             nonce_9: nonce_t <- get2(r_6);
             key_8: key_t <- get1(r_6);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         r_7 <-R keys_t;
         nonce_12: nonce_t <- get2(r_7);
         key_10: key_t <- get1(r_7);
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying equivalence splitter(split)
  - Equivalence splitter(split) with variables: r_7 -> r
yields

Game 30 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part2[ri], part1[ri], r_7[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(r_6[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             nonce_9: nonce_t <- get2(r_6[u_8]);
             key_8: key_t <- get1(r_6[u_8]);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
             nonce_9: nonce_t <- part2[u_4];
             key_8: key_t <- part1[u_4];
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             r_6 <-R keys_t;
             nonce_9: nonce_t <- get2(r_6);
             key_8: key_t <- get1(r_6);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2 <-R nonce_t;
         part1 <-R key_t;
         r_7: keys_t <- cst_keys_t;
         nonce_12: nonce_t <- part2;
         key_10: key_t <- part1;
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying equivalence splitter(split)
  - Equivalence splitter(split) with variables: r_6 -> r
yields

Game 31 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part2[ri], part1[ri], r_7[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], r_6[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             nonce_9: nonce_t <- part2_1[u_8];
             key_8: key_t <- part1_1[u_8];
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
             nonce_9: nonce_t <- part2[u_4];
             key_8: key_t <- part1[u_4];
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             part2_1 <-R nonce_t;
             part1_1 <-R key_t;
             r_6: keys_t <- cst_keys_t;
             nonce_9: nonce_t <- part2_1;
             key_8: key_t <- part1_1;
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2 <-R nonce_t;
         part1 <-R key_t;
         r_7: keys_t <- cst_keys_t;
         nonce_12: nonce_t <- part2;
         key_10: key_t <- part1;
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, key_10, nonce_12);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on r_7 (definition removed, all usages removed)
  - Remove assignments on nonce_12 (definition removed, all usages removed)
  - Remove assignments on key_10 (definition removed, all usages removed)
  - Remove assignments on r_6 (definition removed, all usages removed)
  - Remove assignments on nonce_9 (definition removed, all usages removed)
  - Remove assignments on key_8 (definition removed, all usages removed)
  - Remove assignments on nonce_9 (definition removed, all usages removed)
  - Remove assignments on key_8 (definition removed, all usages removed)
  - Remove assignments on nonce_9 (definition removed, all usages removed)
  - Remove assignments on key_8 (definition removed, all usages removed)
yields

Game 32 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
{154}    find u_4 = ri <= Qcperuser suchthat defined(part2[ri], part1[ri], part1[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
{183}      find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1[u_4], part2[u_4]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             part2_1 <-R nonce_t;
             part1_1 <-R key_t;
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2 <-R nonce_t;
         part1 <-R key_t;
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, part1, part2);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying simplify
  - Simplification pass
    - Replaced defined condition part2_1[ri_8], part1_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8] with part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8] in find at 183
    - Replaced defined condition part2[ri], part1[ri], part1[ri], info_8[ri], s'[ri], ce[ri] with part2[ri], part1[ri], info_8[ri], s'[ri], ce[ri] in find at 154
yields

Game 33 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part2[ri], part1[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1[u_4], part2[u_4]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             part2_1 <-R nonce_t;
             part1_1 <-R key_t;
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2 <-R nonce_t;
         part1 <-R key_t;
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- Seal_inner(pt_8, aad_11, part1, part2);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying equivalence int_ctxt(Seal_inner) with part1 [probability Adv_ctxt(time(context for game 33) + time, #Ochall, #Oadec)]
  - Equivalence int_ctxt(Seal_inner) with variables: part2 -> n, part1 -> k_1
yields

Game 34 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
{243}        let injbot(pt_7: bitstring) = (y: bitstring <- c; c_d: bitstring <- aad_10; if defined(x_2[u_4], d[u_4], r_8[u_4]) && (r_8[u_4] = y) && (d[u_4] = c_d) then injbot(x_2[u_4]) else bottom) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             part2_1 <-R nonce_t;
             part1_1 <-R key_t;
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2 <-R nonce_t;
         part1 <-R key_t;
         pt_8: bitstring <- test(b, m0, m1);
         ct_9: bitstring <- (x_2: bitstring <- pt_8; d: bitstring <- aad_11; r_8: bitstring <- Seal_inner(x_2, d, part1, part2); r_8);
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying expand
  - Expand if/find/let
    - Remove let at 243
    - Simplify pattern injbot(pt_7: bitstring) (tuple expanded) at 243
    - Remove else branch of let at 243
yields

Game 35 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], ct_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (ct_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
             y: bitstring <- c;
             c_d: bitstring <- aad_10;
             if defined(x_2[u_4], d[u_4], r_8[u_4]) && (r_8[u_4] = y) && (d[u_4] = c_d) then
               pt_7: bitstring <- x_2[u_4];
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             part2_1 <-R nonce_t;
             part1_1 <-R key_t;
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2 <-R nonce_t;
         part1 <-R key_t;
         pt_8: bitstring <- test(b, m0, m1);
         x_2: bitstring <- pt_8;
         d: bitstring <- aad_11;
         r_8: bitstring <- Seal_inner(x_2, d, part1, part2);
         ct_9: bitstring <- r_8;
         E_1: pkey_t <- pkgen(s');
         return((ce, ct_9))
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on x_2 (definition removed, all usages removed)
  - Remove assignments on d (definition removed, all usages removed)
  - Remove assignments on ct_9 (definition removed, all usages removed)
  - Remove assignments on y (definition removed, all usages removed)
  - Remove assignments on c_d (definition removed, all usages removed)
  - Remove assignments on pt_7 (definition removed, all usages removed)
yields

Game 36 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
{100}  find u = u_2 <= Qcperuser suchthat defined(r_8[u_2], r_8[u_2], info_8[u_2], aad_11[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (r_8[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
{181}      find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat info_7 = info_8[u_4] then
{245}        if defined(pt_8[u_4], aad_11[u_4], pt_8[u_4], pt_8[u_4], r_8[u_4]) && (r_8[u_4] = c) && (aad_11[u_4] = aad_10) then
               return(OpenAuth_Some(Context_Open_Some(pt_8[u_4])))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             part2_1 <-R nonce_t;
             part1_1 <-R key_t;
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2 <-R nonce_t;
         part1 <-R key_t;
         pt_8: bitstring <- test(b, m0, m1);
         r_8: bitstring <- Seal_inner(pt_8, aad_11, part1, part2);
         E_1: pkey_t <- pkgen(s');
         return((ce, r_8))
       else
         return(bottom)
     ))


Applying simplify
  - Simplification pass
    - Simplified find at 245 in branch of find at 181
    - Replaced defined condition r_8[u_2], r_8[u_2], info_8[u_2], aad_11[u_2], ce[u_2], E_1[u_2] with info_8[u_2], aad_11[u_2], r_8[u_2], ce[u_2], E_1[u_2] in find at 100
yields

Game 37 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], r_8[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (r_8[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
{179}      find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           orfind  suchthat defined(pt_8[u_4], aad_11[u_4], pt_8[u_4], pt_8[u_4], r_8[u_4]) && {254}((info_7 = info_8[u_4]) && (r_8[u_4] = c) && (aad_11[u_4] = aad_10)) then
             return(OpenAuth_Some(Context_Open_Some(pt_8[u_4])))
           else
{293}        if info_7 = info_8[u_4] then
               return(OpenAuth_Some(Context_Open_None))
             else
               part2_1 <-R nonce_t;
               part1_1 <-R key_t;
               let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
                 return(OpenAuth_Some(Context_Open_Some(pt_7)))
               else
                 return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2 <-R nonce_t;
         part1 <-R key_t;
         pt_8: bitstring <- test(b, m0, m1);
         r_8: bitstring <- Seal_inner(pt_8, aad_11, part1, part2);
         E_1: pkey_t <- pkgen(s');
         return((ce, r_8))
       else
         return(bottom)
     ))


Applying simplify
  - Simplification pass
    - Transformed find at 293 into a test
    - Replaced ((info_7 = info_8[u_4]) && (r_8[u_4] = c) && (aad_11[u_4] = aad_10)) with false at 254
    - Remove branch 2 in find at 179
yields

Game 38 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], r_8[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (r_8[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             if info_7 = info_8[u_4] then
               return(OpenAuth_Some(Context_Open_None))
             else
               part2_1 <-R nonce_t;
               part1_1 <-R key_t;
               let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
                 return(OpenAuth_Some(Context_Open_Some(pt_7)))
               else
                 return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2 <-R nonce_t;
         part1 <-R key_t;
         pt_8: bitstring <- test(b, m0, m1);
         r_8: bitstring <- Seal_inner(pt_8, aad_11, part1, part2);
         E_1: pkey_t <- pkgen(s');
         return((ce, r_8))
       else
         return(bottom)
     ))


Applying equivalence ind_cpa(Seal_inner) [probability Adv_cpa(time(context for game 38) + time, #Ochall)]
  - Equivalence ind_cpa(Seal_inner) with variables: part2 -> n, part1 -> k_1
yields

Game 39 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], r_8[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (r_8[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             if info_7 = info_8[u_4] then
               return(OpenAuth_Some(Context_Open_None))
             else
               part2_1 <-R nonce_t;
               part1_1 <-R key_t;
               let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
                 return(OpenAuth_Some(Context_Open_Some(pt_7)))
               else
                 return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2_2 <-R nonce_t;
         part1_2 <-R key_t;
         part1: key_t <- cst_key_t;
         pt_8: bitstring <- test(b, m0, m1);
         r_8: bitstring <- (x_3: bitstring <- pt_8; d_1: bitstring <- aad_11; r_9: bitstring <- enc'(Length(x_3), d_1, part1_2, part2_2); r_9);
         E_1: pkey_t <- pkgen(s');
         return((ce, r_8))
       else
         return(bottom)
     ))


Applying expand
  - Expand if/find/let
yields

Game 40 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], r_8[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (r_8[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             if info_7 = info_8[u_4] then
               return(OpenAuth_Some(Context_Open_None))
             else
               part2_1 <-R nonce_t;
               part1_1 <-R key_t;
               let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
                 return(OpenAuth_Some(Context_Open_Some(pt_7)))
               else
                 return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2_2 <-R nonce_t;
         part1_2 <-R key_t;
         part1: key_t <- cst_key_t;
         pt_8: bitstring <- test(b, m0, m1);
         x_3: bitstring <- pt_8;
         d_1: bitstring <- aad_11;
         r_9: bitstring <- enc'(Length(x_3), d_1, part1_2, part2_2);
         r_8: bitstring <- r_9;
         E_1: pkey_t <- pkgen(s');
         return((ce, r_8))
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on part1 (definition removed, all usages removed)
  - Remove assignments on x_3 (definition removed, all usages removed)
  - Remove assignments on d_1 (definition removed, all usages removed)
  - Remove assignments on r_8 (definition removed, all usages removed)
yields

Game 41 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
{100}  find u = u_2 <= Qcperuser suchthat defined(r_9[u_2], r_9[u_2], info_8[u_2], aad_11[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (r_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1_2[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             if info_7 = info_8[u_4] then
               return(OpenAuth_Some(Context_Open_None))
             else
               part2_1 <-R nonce_t;
               part1_1 <-R key_t;
               let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
                 return(OpenAuth_Some(Context_Open_Some(pt_7)))
               else
                 return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2_2 <-R nonce_t;
         part1_2 <-R key_t;
         pt_8: bitstring <- test(b, m0, m1);
         r_9: bitstring <- {390}enc'(Length(pt_8), aad_11, part1_2, part2_2);
         E_1: pkey_t <- pkgen(s');
         return((ce, r_9))
       else
         return(bottom)
     ))


Applying simplify
  - Simplification pass
    - Replaced enc'(Length(pt_8), aad_11, part1_2, part2_2) with enc'(Length(m0), aad_11, part1_2, part2_2) at 390
    - Replaced defined condition r_9[u_2], r_9[u_2], info_8[u_2], aad_11[u_2], ce[u_2], E_1[u_2] with info_8[u_2], aad_11[u_2], r_9[u_2], ce[u_2], E_1[u_2] in find at 100
yields

Game 42 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], r_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (r_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1_2[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             if info_7 = info_8[u_4] then
               return(OpenAuth_Some(Context_Open_None))
             else
               part2_1 <-R nonce_t;
               part1_1 <-R key_t;
               let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
                 return(OpenAuth_Some(Context_Open_Some(pt_7)))
               else
                 return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2_2 <-R nonce_t;
         part1_2 <-R key_t;
         pt_8: bitstring <- test(b, m0, m1);
         r_9: bitstring <- enc'(Length(m0), aad_11, part1_2, part2_2);
         E_1: pkey_t <- pkgen(s');
         return((ce, r_9))
       else
         return(bottom)
     ))


Applying remove assignments of findcond
  - Remove assignments on pt_8 (definition removed, all usages removed)
yields

Game 43 is
     Ostart() :=
     b <-R bool;
     return();
     foreach i <= N do
     Osetup() :=
     s <-R keypairseed_t;
     return(pkgen(s));
     ((
       foreach iae <= Qeperuser do
       Oaenc(pk_3: pkey_t, m: bitstring, aad_9: bitstring, info_6: bitstring) :=
       k_4 <-R kemseed_t;
       sk_2: skey_t <- skgen(s);
       enc_5: kemciph_t <- AuthEncap_enc_r(k_4, pk_3, sk_2);
       shared_secret_3: kemkey_t <- AuthEncap_key_r(k_4, pk_3, sk_2);
       r_3: keys_t <- KeySchedule_auth(shared_secret_3, info_6);
       nonce_6: nonce_t <- get2(r_3);
       key_6: key_t <- get1(r_3);
       ct_7: bitstring <- Seal_inner(m, aad_9, key_6, nonce_6);
       return(SealAuth_Some(enc_5, ct_7))
     ) | (
       foreach iad <= Qdperuser do
       Oadec(pk_4: pkey_t, enc_7: kemciph_t, c: bitstring, aad_10: bitstring, info_7: bitstring) :=
       find u = u_2 <= Qcperuser suchthat defined(info_8[u_2], aad_11[u_2], r_9[u_2], ce[u_2], E_1[u_2]) && (E_1[u_2] = pk_4) && (ce[u_2] = enc_7) && (r_9[u_2] = c) && (aad_11[u_2] = aad_10) && (info_8[u_2] = info_7) then
         return(OpenAuth_None)
       else
         find u_4 = ri <= Qcperuser suchthat defined(part1_2[ri], info_8[ri], s'[ri], ce[ri]) && (ce[ri] = enc_7) && (pkgen(s'[ri]) = pk_4) then
           find [unique] u_8 = ri_8 <= Qdperuser suchthat defined(part2_1[ri_8], part1_1[ri_8], info_7[ri_8], u_4[ri_8]) && (u_4[ri_8] = u_4) && (info_7 = info_7[ri_8]) then
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1[u_8], part2_1[u_8]) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             if info_7 = info_8[u_4] then
               return(OpenAuth_Some(Context_Open_None))
             else
               part2_1 <-R nonce_t;
               part1_1 <-R key_t;
               let injbot(pt_7: bitstring) = Open_inner(c, aad_10, part1_1, part2_1) in
                 return(OpenAuth_Some(Context_Open_Some(pt_7)))
               else
                 return(OpenAuth_Some(Context_Open_None))
         else
           let AuthDecap_Some(shared_secret_4: kemkey_t) = AuthDecap(enc_7, skgen(s), pk_4) in
             r_4: keys_t <- KeySchedule_auth(shared_secret_4, info_7);
             nonce_9: nonce_t <- get2(r_4);
             key_8: key_t <- get1(r_4);
             let injbot(pt_7: bitstring) = Open_inner(c, aad_10, key_8, nonce_9) in
               return(OpenAuth_Some(Context_Open_Some(pt_7)))
             else
               return(OpenAuth_Some(Context_Open_None))
           else
             return(OpenAuth_None)
     ) | (
       foreach ich <= Qcperuser do
       Ochall(s': keypairseed_t, m0: bitstring, m1: bitstring, aad_11: bitstring, info_8: bitstring) :=
       if Length(m0) = Length(m1) then
         k_6 <-R kemseed_t;
         pk_6: pkey_t <- pkgen(s);
         sk_3: skey_t <- skgen(s');
         ce: kemciph_t <- AuthEncap_enc_r(k_6, pk_6, sk_3);
         part2_2 <-R nonce_t;
         part1_2 <-R key_t;
         r_9: bitstring <- enc'(Length(m0), aad_11, part1_2, part2_2);
         E_1: pkey_t <- pkgen(s');
         return((ce, r_9))
       else
         return(bottom)
     ))


Proved secrecy of b in game 43
Adv[Game 1: secrecy of b] <= 2 * Adv_cpa(time_1, #Ochall) + 2 * Adv_ctxt(time_2, #Ochall, #Oadec) + 2 * Adv_PRF_KeySchedule(time_3, #Ochall, #Ochall + #Oadec) + 2 * Adv_Insider_CCA(time_4, N, #Oaenc, #Ochall, #Oadec) + 6 * N * N * P_pk_coll + Adv[Game 43: secrecy of b]
Adv[Game 43: secrecy of b] <= 0
RESULT Proved secrecy of b up to probability 2 * Adv_cpa(time_1, #Ochall) + 2 * Adv_ctxt(time_2, #Ochall, #Oadec) + 2 * Adv_PRF_KeySchedule(time_3, #Ochall, #Ochall + #Oadec) + 2 * Adv_Insider_CCA(time_4, N, #Oaenc, #Ochall, #Oadec) + 6 * N * N * P_pk_coll
RESULT time_1 = time(context for game 38) + time
RESULT time_2 = time(context for game 33) + time
RESULT time_3 = time(context for game 21) + time
RESULT time_4 = time(context for game 10) + time
RESULT time(context for game 10) = (#Oaenc + #Ochall) * time(let AuthEncap_tuple) + #Oaenc * time(KeySchedule_auth, maxlength(game 10: info_6)) + (#Oaenc + #Oadec + #Ochall) * time(get2) + (#Oaenc + #Oadec + #Ochall) * time(get1) + #Oaenc * time(Seal_inner, maxlength(game 10: m), maxlength(game 10: aad_9)) + #Oaenc * time(SealAuth_Some, maxlength(game 10: ct_7)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 10: ct_9), maxlength(game 10: c)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 10: aad_11), maxlength(game 10: aad_10)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 10: info_8), maxlength(game 10: info_7)) + #Oadec * time(let AuthDecap_Some) + #Oadec * time(KeySchedule_auth, maxlength(game 10: info_7)) + #Oadec * time(Open_inner, maxlength(game 10: c), maxlength(game 10: aad_10)) + #Oadec * time(let injbot, maxlength(game 10: pt_7)) + #Oadec * time(OpenAuth_Some, length(Context_Open_Some, maxlength(game 10: pt_7))) + #Oadec * time(Context_Open_Some, maxlength(game 10: pt_7)) + #Oadec * time(OpenAuth_Some, length(Context_Open_None)) + #Ochall * time(= bitstring, length(Length, maxlength(game 10: m0)), length(Length, maxlength(game 10: m1))) + #Ochall * time(Length, maxlength(game 10: m1)) + #Ochall * time(Length, maxlength(game 10: m0)) + #Ochall * time(skgen) + #Ochall * time(KeySchedule_auth, maxlength(game 10: info_8)) + #Ochall * time(test, maxlength(game 10: m0), maxlength(game 10: m1)) + #Ochall * time(Seal_inner, maxlength(game 10: pt_8), maxlength(game 10: aad_11)) + #Ochall * time(pkgen)
RESULT time(context for game 21) = (N + #Oadec * Qcperuser + 2 * #Ochall) * time(pkgen) + (#Oaenc + #Oadec + #Ochall) * time(skgen) + (#Oaenc + #Ochall) * time(AuthEncap_enc_r) + #Oaenc * time(AuthEncap_key_r) + #Oaenc * time(KeySchedule_auth, maxlength(game 21: info_6)) + (#Oaenc + #Oadec + #Ochall) * time(get2) + (#Oaenc + #Oadec + #Ochall) * time(get1) + #Oaenc * time(Seal_inner, maxlength(game 21: m), maxlength(game 21: aad_9)) + #Oaenc * time(SealAuth_Some, maxlength(game 21: ct_7)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 21: ct_9), maxlength(game 21: c)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 21: aad_11), maxlength(game 21: aad_10)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 21: info_8), maxlength(game 21: info_7)) + #Oadec * time(AuthDecap) + #Oadec * time(let AuthDecap_Some) + #Oadec * time(KeySchedule_auth, maxlength(game 21: info_7)) + #Oadec * time(Open_inner, maxlength(game 21: c), maxlength(game 21: aad_10)) + #Oadec * time(let injbot, maxlength(game 21: pt_7)) + #Oadec * time(OpenAuth_Some, length(Context_Open_Some, maxlength(game 21: pt_7))) + #Oadec * time(Context_Open_Some, maxlength(game 21: pt_7)) + #Oadec * time(OpenAuth_Some, length(Context_Open_None)) + #Ochall * time(= bitstring, length(Length, maxlength(game 21: m0)), length(Length, maxlength(game 21: m1))) + #Ochall * time(Length, maxlength(game 21: m1)) + #Ochall * time(Length, maxlength(game 21: m0)) + #Ochall * time(test, maxlength(game 21: m0), maxlength(game 21: m1)) + #Ochall * time(Seal_inner, maxlength(game 21: pt_8), maxlength(game 21: aad_11))
RESULT time(context for game 33) = (N + #Oadec * Qcperuser + 2 * #Ochall) * time(pkgen) + (#Oaenc + #Oadec + #Ochall) * time(skgen) + (#Oaenc + #Ochall) * time(AuthEncap_enc_r) + #Oaenc * time(AuthEncap_key_r) + #Oaenc * time(KeySchedule_auth, maxlength(game 33: info_6)) + (#Oaenc + #Oadec) * time(get2) + (#Oaenc + #Oadec) * time(get1) + #Oaenc * time(Seal_inner, maxlength(game 33: m), maxlength(game 33: aad_9)) + #Oaenc * time(SealAuth_Some, maxlength(game 33: ct_7)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 33: ct_9), maxlength(game 33: c)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 33: aad_11), maxlength(game 33: aad_10)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 33: info_8), maxlength(game 33: info_7)) + #Oadec * Qdperuser * time(= bitstring, maxlength(game 33: info_7), maxlength(game 33: info_7)) + #Oadec * time(= bitstring, maxlength(game 33: info_7), maxlength(game 33: info_8)) + #Oadec * time(AuthDecap) + #Oadec * time(let AuthDecap_Some) + #Oadec * time(KeySchedule_auth, maxlength(game 33: info_7)) + #Oadec * time(Open_inner, maxlength(game 33: c), maxlength(game 33: aad_10)) + #Oadec * time(let injbot, maxlength(game 33: pt_7)) + #Oadec * time(OpenAuth_Some, length(Context_Open_Some, maxlength(game 33: pt_7))) + #Oadec * time(Context_Open_Some, maxlength(game 33: pt_7)) + #Oadec * time(OpenAuth_Some, length(Context_Open_None)) + #Ochall * time(= bitstring, length(Length, maxlength(game 33: m0)), length(Length, maxlength(game 33: m1))) + #Ochall * time(Length, maxlength(game 33: m1)) + #Ochall * time(Length, maxlength(game 33: m0)) + #Ochall * time(test, maxlength(game 33: m0), maxlength(game 33: m1))
RESULT time(context for game 38) = (N + #Oadec * Qcperuser + 2 * #Ochall) * time(pkgen) + (#Oaenc + #Oadec + #Ochall) * time(skgen) + (#Oaenc + #Ochall) * time(AuthEncap_enc_r) + #Oaenc * time(AuthEncap_key_r) + #Oaenc * time(KeySchedule_auth, maxlength(game 38: info_6)) + (#Oaenc + #Oadec) * time(get2) + (#Oaenc + #Oadec) * time(get1) + #Oaenc * time(Seal_inner, maxlength(game 38: m), maxlength(game 38: aad_9)) + #Oaenc * time(SealAuth_Some, maxlength(game 38: ct_7)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 38: r_8), maxlength(game 38: c)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 38: aad_11), maxlength(game 38: aad_10)) + #Oadec * Qcperuser * time(= bitstring, maxlength(game 38: info_8), maxlength(game 38: info_7)) + #Oadec * Qdperuser * time(= bitstring, maxlength(game 38: info_7), maxlength(game 38: info_7)) + #Oadec * time(= bitstring, maxlength(game 38: info_7), maxlength(game 38: info_8)) + #Oadec * time(AuthDecap) + #Oadec * time(let AuthDecap_Some) + #Oadec * time(KeySchedule_auth, maxlength(game 38: info_7)) + #Oadec * time(Open_inner, maxlength(game 38: c), maxlength(game 38: aad_10)) + #Oadec * time(let injbot, maxlength(game 38: pt_7)) + #Oadec * time(OpenAuth_Some, length(Context_Open_Some, maxlength(game 38: pt_7))) + #Oadec * time(Context_Open_Some, maxlength(game 38: pt_7)) + #Oadec * time(OpenAuth_Some, length(Context_Open_None)) + #Ochall * time(= bitstring, length(Length, maxlength(game 38: m0)), length(Length, maxlength(game 38: m1))) + #Ochall * time(Length, maxlength(game 38: m1)) + #Ochall * time(Length, maxlength(game 38: m0)) + #Ochall * time(test, maxlength(game 38: m0), maxlength(game 38: m1))
All queries proved.
